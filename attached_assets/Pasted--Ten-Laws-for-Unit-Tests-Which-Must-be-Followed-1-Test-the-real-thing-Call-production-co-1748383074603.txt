# Ten Laws for Unit Tests Which Must be Followed

1. **Test the real thing.**
   Call production code—not copies, not helper facades—and assert on its *observable* outputs or side-effects.
2. **One reason to fail.**
   Structure each test around a single behaviour or branch (Arrange → Act → Assert). Multiple assertions are fine if they cover the same concept.
3. **Mock only the boundary, never the subject.**
   Stub or mock *external* collaborators you don’t control (DB, message bus, HTTP service), but never the class or function under test.
4. **Don’t re-implement logic in the test.**
   Hard-code simple inputs and the expected result; duplicating algorithms inside the test just hides bugs.
5. **Keep tests independent and stateless.**
   No shared globals, singletons, or reused objects across test cases; reset or re-create fresh fixtures every run.
6. **Fail fast, diagnostically.**
   A failing assertion must read like an error message a human can act on instantly—avoid cryptic comparisons or large diffs.
7. **Adapt the test, not the production code.**
   If a deliberate refactor breaks a test, fix the test. Add logic to production code *only* when it serves real behaviour, never as a shim to appease a test.
8. **Be deterministic and fast.**
   Eliminate randomness, real time, network, and file-system dependencies; aim for sub-second execution so the suite is run constantly.
9. **Cover contracts, not percentages.**
   Strive for meaningful paths and edge cases; 100 % line-coverage is worthless if assertions are superficial.
10. **Validate external-system assumptions separately.**
    Write contract/integration tests against a real instance, container, or contract verifier to ensure your mocks reflect reality.

# Unit Test Naming Conventions

* For Python tests, please use following module / file naming scheme: test_<module under test>\[_<specific test topic>\].py.
* For Javascript tests, please use following module / file naming scheme: <module under test>.test.js

# How to Deal With Unexpected Application or Code  Behaviour

1. First make sure you really understand the problem properly.
2. Challenge and validate your assumptions. Is there really happening what you assume to happen? Incorrect assumptions about what is happening are a frequent reason for unexpected problems. Tests and logging can be used to confirm what's really happening.
3. Assume external systems and services you need to interface with are working correctly according to the specification, unless you explicitly know otherwise. Do not create workaround code for hypothetical problems in other services which most likely don't exist.
4. Always focus on identifying and resolving the root cause instead of adding “work-around code.” Such work-around code is nearly always the wrong approach and adds unnecessary complexity and maintenance issues.
